"""
This type stub file was generated by pyright.
"""

import railroad
import pyparsing
import typing
import inspect
from typing import Callable, Dict, Generic, Iterable, List, NamedTuple, Set, TypeVar
from jinja2 import Template
from io import StringIO

jinja2_template_source = ...
template = ...
NamedDiagram = ...
T = TypeVar("T")
class EachItem(railroad.Group):
    """
    Custom railroad item to compose a:
    - Group containing a
      - OneOrMore containing a
        - Choice of the elements in the Each
    with the group label indicating that all must be matched
    """
    all_label = ...
    def __init__(self, *items) -> None:
        ...
    


class AnnotatedItem(railroad.Group):
    """
    Simple subclass of Group that creates an annotation label
    """
    def __init__(self, label: str, item) -> None:
        ...
    


class EditablePartial(Generic[T]):
    """
    Acts like a functools.partial, but can be edited. In other words, it represents a type that hasn't yet been
    constructed.
    """
    def __init__(self, func: Callable[..., T], args: list, kwargs: dict) -> None:
        ...
    
    @classmethod
    def from_call(cls, func: Callable[..., T], *args, **kwargs) -> EditablePartial[T]:
        """
        If you call this function in the same way that you would call the constructor, it will store the arguments
        as you expect. For example EditablePartial.from_call(Fraction, 1, 3)() == Fraction(1, 3)
        """
        ...
    
    @property
    def name(self):
        ...
    
    def __call__(self) -> T:
        """
        Evaluate the partial and return the result
        """
        ...
    


def railroad_to_html(diagrams: List[NamedDiagram], embed=..., **kwargs) -> str:
    """
    Given a list of NamedDiagram, produce a single HTML string that visualises those diagrams
    :params kwargs: kwargs to be passed in to the template
    """
    ...

def resolve_partial(partial: EditablePartial[T]) -> T:
    """
    Recursively resolves a collection of Partials into whatever type they are
    """
    ...

def to_railroad(element: pyparsing.ParserElement, diagram_kwargs: typing.Optional[dict] = ..., vertical: int = ..., show_results_names: bool = ..., show_groups: bool = ...) -> List[NamedDiagram]:
    """
    Convert a pyparsing element tree into a list of diagrams. This is the recommended entrypoint to diagram
    creation if you want to access the Railroad tree before it is converted to HTML
    :param element: base element of the parser being diagrammed
    :param diagram_kwargs: kwargs to pass to the Diagram() constructor
    :param vertical: (optional) - int - limit at which number of alternatives should be
       shown vertically instead of horizontally
    :param show_results_names - bool to indicate whether results name annotations should be
       included in the diagram
    :param show_groups - bool to indicate whether groups should be highlighted with an unlabeled
       surrounding box
    """
    ...

class ElementState:
    """
    State recorded for an individual pyparsing Element
    """
    def __init__(self, element: pyparsing.ParserElement, converted: EditablePartial, parent: EditablePartial, number: int, name: str = ..., parent_index: typing.Optional[int] = ...) -> None:
        ...
    
    def mark_for_extraction(self, el_id: int, state: ConverterState, name: str = ..., force: bool = ...): # -> None:
        """
        Called when this instance has been seen twice, and thus should eventually be extracted into a sub-diagram
        :param el_id: id of the element
        :param state: element/diagram state tracker
        :param name: name to use for this element's text
        :param force: If true, force extraction now, regardless of the state of this. Only useful for extracting the
        root element when we know we're finished
        """
        ...
    


class ConverterState:
    """
    Stores some state that persists between recursions into the element tree
    """
    def __init__(self, diagram_kwargs: typing.Optional[dict] = ...) -> None:
        ...
    
    def __setitem__(self, key: int, value: ElementState): # -> None:
        ...
    
    def __getitem__(self, key: int) -> ElementState:
        ...
    
    def __delitem__(self, key: int): # -> None:
        ...
    
    def __contains__(self, key: int): # -> bool:
        ...
    
    def generate_unnamed(self) -> int:
        """
        Generate a number used in the name of an otherwise unnamed diagram
        """
        ...
    
    def generate_index(self) -> int:
        """
        Generate a number used to index a diagram
        """
        ...
    
    def extract_into_diagram(self, el_id: int): # -> None:
        """
        Used when we encounter the same token twice in the same tree. When this
        happens, we replace all instances of that token with a terminal, and
        create a new subdiagram for the token
        """
        ...
    


